{
  "hash": "5f0c5b10582d883248e85610d6619bac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Just how *universal* is \"Universal\"?'\ndate: 2023-12-18\ncategories: [spatial]\n---\n\n\nContinued from the previous post...\n\nA question was thrown into the ether a few days ago that gave me a reason to learn a little bit of R's [`terra`](https://rspatial.github.io/terra/index.html) package. The answer, itself, turned out to be not overly complicated (in spite of a few frustrating hurdles). However, what I extracted from this was one more brick in my wall against the blind use of Universal Transverse Mercator (UTM). Through a worked example, I hope to instill this in you!\n\nThe question: If I have a grid of points that each contain some value from an observing system -- say sea surface temperature -- and a bunch of fish detections within that grid, how do I extract the temperature values at each one of those detections? \n\n\n# Create example data\n\nFirst, let's make up our sampled grid. I'll make it 20 rows tall and 50 columns wide for no real reason other than the rectangle it makes looks kinda good.\n\nI'm picking a region on the east coast of Canada. You would be able to see the distortion I'll be talking about in areas farther south, but it's more prominent the farther you move toward the pole.\n\nThen, I'll randomly draw values from a poisson distribution solely to keep things positive integers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gridded data\nn_rows <- 20\nn_cols <- 50\n\ngrid_data <- data.frame(\n  lon = rep(\n    seq(-64.47, -64.37, length.out = n_cols),\n    each = n_rows\n  ),\n  lat = rep(\n    seq(45.33, 45.38, length.out = n_rows),\n    times = n_cols\n  ),\n  data_value = rpois(n_cols * n_rows, lambda = 20)\n)\n\nplot(lat ~ lon, data = grid_data,\n     col = grid_data$data_value, cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nNow, I'll create a handful of fish \"detections\". I'm not being too exacting here, so some are likely to not even be within our grid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Random detections\ndets <- data.frame(\n  lon = rnorm(20, -64.42, 0.02),\n  lat = rnorm(20, 45.35, 0.02)\n)\n\nplot(lat ~ lon, data = grid_data,\n     col = grid_data$data_value, cex = 0.5)\npoints(dets$lon, dets$lat, col = 'red', cex = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n# Convert to spatial objects\n\nNext, convert the data frames into spatial objects using the `terra` package. We'll do this by first telling `terra` that the grid are points in WGS84. `terra::vect` turns a data frame (`x`) into a vector `geom`etry (points, lines, and polygons) defined by the `lon` and `lat` columns in the given coordinate reference system. The `crs` we've provided is in [PROJ-string](https://proj.org/en/9.3/operations/conversions/latlon.html) notation, letting `terra::vect` know that we want our longitude/latitude coordinates to be in the \"datum\" of [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS_84).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.55\n```\n\n\n:::\n\n```{.r .cell-code}\nlonlat_crs <- \"+proj=lonlat +datum=WGS84\"\n\ngrid_lonlat <- vect(x = grid_data,\n                    geom = c('lon', 'lat'),\n                    crs = lonlat_crs)\n\nplot(grid_lonlat, col = grid_lonlat$data_value)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nGreat! Now, let's turn that vector into a raster (something spatially gridded that contains values).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_rast_lonlat <- rast(x = grid_lonlat)\n\nplot(grid_rast_lonlat)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nUhh... where'd all of our data go?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange(values(grid_rast_lonlat))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [readValues] raster has no values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN NaN\n```\n\n\n:::\n:::\n\nSeems like it's not that easy to convert a gridded SpatVector (what was created by `terra::vect`) to a SpatRaster. I'd love to be corrected on this, so [let me know if I'm wrong](mailto:mike@obrien.page)!\n\nWhat we can do, however, is convert the originial data frame directly into a raster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_rast_lonlat <- rast(x = grid_data,\n                         type = 'xyz',\n                         crs = lonlat_crs)\n\nplot(grid_rast_lonlat)\nplot(grid_lonlat,\n     add = T, cex = 0.2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nLastly, convert the detections.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndets_lonlat <- vect(\n  dets,\n  crs = lonlat_crs\n)\n\nplot(grid_rast_lonlat)\nplot(grid_lonlat, add = T, cex = 0.2)\nplot(dets_lonlat, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNow we're ready to extract those values!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvals_lonlat <- extract(grid_rast_lonlat, dets_lonlat)\nhead(vals_lonlat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID data_value\n1  1         27\n2  2         18\n3  3         16\n4  4         18\n5  5         23\n6  6         21\n```\n\n\n:::\n:::\n\n\nSeems to have worked. The `ID` column refers to the index of the detection and `data_value` refers to the value extracted from our rasterized grid. Any `NA` in the `data_value` column indicates that the detection was not within the grid's bounds.\n\n## Aside for those with incomplete grids\n\nNote that this only works if your gridded data has all latitude and longitude combinations. This often isn't the case: there may be land that, in fisheries, should have no value, or maybe there's a precision issue wherein \"38.123456\" won't be read as \"38.12345\" even though they're basically the same. This will be a pretty big tangent, so [skip ahead](#utm) if you want to get back to the proejction stuff!\n\n<!-- ## Remove \"land\" around -64.39, 45.35 -->\n<!-- grid_data <- grid_data[grid_data$lon <= -64.39 | -->\n<!--                          grid_data$lat < 45.35,] -->\n\n<!-- plot(grid_data$lon, grid_data$lat, cex = 0.5) -->\n\nThe essence of what we want to do here is to create a blank raster and tell the program to use the values of our grid to fill the value for each raster cell. In order to do this, we need to tell `terra` what the extent of the raster should be, then carve up the rectangle with those dimensions into little blocks.\n\nWhen we think about an even grid like the one we created above, note that our extent isn't the values, it's the values... plus a little bit. We'll find the nudge by taking the range of the latitude or longitude values, dividing it by the number of rows or columns we wanted, then dividing that in half.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlon_nudge <- \n  # range of values...\n  ((max(grid_data$lon) - min(grid_data$lon)) /\n     # divided by the number of columns (declared above)\n                n_cols) /\n  # divided by two\n  2\n\nlat_nudge <- ((max(grid_data$lat) - min(grid_data$lat)) /\n                n_rows) /\n  2\n```\n:::\n\n\nNow, make the mask using the \"nudged\" dimensions...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_mask <- rast(\n  nrows = n_rows,\n  ncol = n_cols,\n  xmin = min(grid_data$lon) - lon_nudge,\n  xmax = max(grid_data$lon) + lon_nudge,\n  ymin = min(grid_data$lat) - lat_nudge,\n  ymax = max(grid_data$lat) + lat_nudge,\n  crs = '+proj=longlat +datum=WGS84',\n  vals = NA\n)\n```\n:::\n\n\n...and rasterize the vector grid based on the desired values (here, they're called \"`data_value`\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_rast <- rasterize(x = grid_lonlat,\n                       y = grid_mask,\n                       field = 'data_value')\n\nplot(grid_rast)\nplot(grid_lonlat, add = T, cex = 0.2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThese rasters are not identical -- the extent of `grid_rast` was rounded during this process -- but they are functionally close-enough.\n\n# Universal Transverse Mercator {#utm}\n\n::: {.cell}\n\n```{.r .cell-code}\nutm_crs <- '+proj=utm +zone=20'\ngrid_utm <- project(grid_lonlat, utm_crs)\ngrid_rast_utm <- rasterize(grid_utm,\n                           rast(ext(grid_utm) *\n                                  (1+rep(c(1/n_cols, 1/n_rows),\n                                         each = 2)),\n                                nrows = n_rows,\n                                ncols = n_cols,\n                                names = 'data_value'),\n                           field = 'data_value')\nnames(grid_rast_utm) <- 'data_value'\n\ndets_utm <- project(dets_lonlat, utm_crs)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(grid_rast_utm)\nplot(grid_utm, add = T, cex = 0.2)\nplot(dets_utm, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndef.par <- par(no.readonly = T)\npar(mfrow = c(2,1))\n\n\nplot(grid_rast_lonlat)\nplot(grid_lonlat, add = T, cex = 0.2)\nplot(dets_lonlat, add = T)\n\nplot(grid_rast_utm)\nplot(grid_utm, add = T, cex = 0.2)\nplot(dets_utm, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(def.par)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvals_utm <- extract(grid_rast_utm, dets_utm)\nidentical(vals_lonlat, vals_utm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n# Azimuthal Equidistant (AQED)\n\n::: {.cell}\n\n```{.r .cell-code}\naeqd_crs <- sprintf(\n  '+proj=aeqd +x_0=5000 +y_0=5000 +lat_0=%f +lon_0=%f',\n  mean(grid_data$lat),\n  mean(grid_data$lon)\n)\n\naeqd_crs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"+proj=aeqd +x_0=5000 +y_0=5000 +lat_0=45.355000 +lon_0=-64.420000\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_aeqd <- project(grid_lonlat, aeqd_crs)\ngrid_rast_aeqd <- rasterize(grid_aeqd,\n                           rast(ext(grid_aeqd) *\n                                  (1+rep(c(1/n_cols, 1/n_rows),\n                                         each = 2)),\n                                nrows = n_rows,\n                                ncols = n_cols,\n                                crs = aeqd_crs),\n                           'data_value',\n                           update = T)\nnames(grid_rast_aeqd) <- 'data_value'\n\ndets_aeqd <- project(dets_lonlat, aeqd_crs)\nplot(grid_rast_aeqd)\nplot(grid_aeqd, add = T, cex = 0.2)\nplot(dets_aeqd, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvals_aeqd <- extract(grid_rast_aeqd, dets_aeqd)\nidentical(vals_lonlat, vals_aeqd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n# Just any ol' Transverse Mercator (TMERC)\n\n::: {.cell}\n\n```{.r .cell-code}\ntmerc_crs <- sprintf(\n  '+proj=tmerc +x_0=5000 +y_0=5000 +lat_0=%f +lon_0=%f',\n  mean(grid_data$lat),\n  mean(grid_data$lon)\n)\n\ntmerc_crs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"+proj=tmerc +x_0=5000 +y_0=5000 +lat_0=45.355000 +lon_0=-64.420000\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_tmerc <- project(grid_lonlat, tmerc_crs)\ngrid_rast_tmerc <- rasterize(grid_tmerc,\n                           rast(ext(grid_tmerc) *\n                                  (1+rep(c(1/n_cols, 1/n_rows),\n                                         each = 2)),\n                                nrows = n_rows,\n                                ncols = n_cols,\n                                crs = tmerc_crs),\n                           'data_value',\n                           update = T)\nnames(grid_rast_tmerc) <- 'data_value'\n\ndets_tmerc <- project(dets_lonlat, tmerc_crs)\nplot(grid_rast_tmerc)\nplot(grid_tmerc, add = T, cex = 0.2)\nplot(dets_tmerc, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvals_tmerc <- extract(grid_rast_tmerc, dets_tmerc)\nidentical(vals_lonlat, vals_tmerc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n<!-- ############# -->\n\n<!-- oct <- read.csv('octle_mp.csv') -->\n<!-- oct <- read.csv('c:/users/darpa2/downloads/octle_mp.csv') -->\n<!-- sb <- read.csv('sbasshourly_octle.csv') -->\n\n<!-- oct$lon <- round(oct$lon, 5) -->\n<!-- oct$lat <- round(oct$lat, 5) -->\n\n<!-- oct_mask <- rast( -->\n<!--   nrows = length(unique(round(oct$lat, 5))), -->\n<!--   ncol = length(unique(round(oct$lon, 5))), -->\n<!--   xmin = min(oct$lon) - lon_skosh, -->\n<!--   xmax = max(oct$lon) + lon_skosh, -->\n<!--   ymin = min(oct$lat) - lat_skosh, -->\n<!--   ymax = max(oct$lat) + lat_skosh, -->\n<!--   crs = '+proj=longlat +datum=WGS84', -->\n<!--   vals = NA -->\n<!-- ) -->\n<!-- oct_vect <- vect( -->\n<!--   oct, -->\n<!--   crs = '+proj=longlat +datum=WGS84' -->\n<!-- ) -->\n<!-- oct_rast <- terra::rasterize( -->\n<!--   oct_vect, -->\n<!--   oct_mask, -->\n<!--   'mp_percentile' -->\n<!-- ) -->\n\n<!-- plot(oct_rast, colNA = 'lightgray') -->\n<!-- plot(oct_vect, add = T, cex = 0.2) -->\n\n<!-- sb_vect <- vect( -->\n<!--   sb, -->\n<!--   crs = \"+proj=lonlat +datum=WGS84\" -->\n<!-- ) -->\n\n<!-- plot(sb_vect, add = T) -->\n\n<!-- vals <- extract(oct_rast, sb_vect) -->\n<!-- head(vals) -->\n\n\n\n<!-- oct_vect_proj <- project(oct_vect, \"+proj=utm +zone=20\") -->\n<!-- lat_skosh <- (ext(oct_vect_proj)[4] - ext(oct_vect_proj)[3]) /  -->\n<!--   length(unique(round(oct$lat, 5))) -->\n<!-- lon_skosh <- (ext(oct_vect_proj)[2] - ext(oct_vect_proj)[1]) /  -->\n<!--   length(unique(round(oct$lon, 5))) -->\n<!-- oct_mask_proj <- rast( -->\n<!--   nrows = length(unique(round(oct$lat, 5))), -->\n<!--   ncol = length(unique(round(oct$lon, 5))), -->\n<!--   xmin = ext(oct_vect_proj)[1] - lon_skosh/2, -->\n<!--   xmax = ext(oct_vect_proj)[2] + lon_skosh/2, -->\n<!--   ymin = ext(oct_vect_proj)[3] - lat_skosh/2, -->\n<!--   ymax = ext(oct_vect_proj)[4] + lat_skosh/2, -->\n<!--   crs = \"+proj=utm +zone=20\", -->\n<!--   vals = NA -->\n<!-- ) -->\n\n<!-- oct_rast_proj <- terra::rasterize( -->\n<!--   oct_vect_proj, -->\n<!--   oct_mask_proj, -->\n<!--   'mp_percentile' -->\n<!-- ) -->\n\n<!-- sb_vect_proj <- project(sb_vect, \"+proj=utm +zone=20\") -->\n<!-- vals_proj <- extract(oct_rast_proj, sb_vect_proj) -->\n\n<!-- plot(oct_rast_proj, colNA = 'lightgray') -->\n<!-- plot(oct_vect_proj, add = T, cex = 0.2) -->\n<!-- # plot(sb_vect_proj, add = T) -->\n<!-- # vals <- data.frame(lon = rnorm(100, mean = -63), -->\n<!-- #                              lat = rnorm(100, 45), -->\n<!-- #                              vals = rpois(100, 10)) -->\n<!-- # vals_sf <- st_as_sf(vals, -->\n<!-- #                  coords = c('lon', 'lat'), -->\n<!-- #                  crs = '+proj=longlat +datum=WGS84') -->\n<!-- # vals_vect <- vect(vals_sf) -->\n<!-- # vals_rast <- rasterize(vals_vect, -->\n<!-- #                        rast(nrows = 10, ncol = 10, -->\n<!-- #                             xmin = min(vals$lon), xmax = max(vals$lon), -->\n<!-- #                             ymin = min(vals$lat), ymax = max(vals$lat), -->\n<!-- #                             crs = '+proj=longlat +datum=WGS84'), -->\n<!-- #                        values = values(vals_vect)) -->\n<!-- # values_projected <- project(vals_rast, -->\n<!-- #                             '+proj=utm +zone=20 +datum=WGS84') -->\n\n<!-- sb <- data.frame(lon = rnorm(50, mean = -63), -->\n<!--                  lat = rnorm(50, 45)) -->\n<!-- sb <- st_as_sf(sb, -->\n<!--                coords = c('lon', 'lat'), -->\n<!--                crs = '+proj=longlat +datum=WGS84') -->\n<!-- sb_vect <- vect(sb) -->\n<!-- sb_vect <- project(sb_vect, '+proj=utm +zone=20 +datum=WGS84') -->\n\n<!-- extract(values_projected, sb_vect) -->\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}